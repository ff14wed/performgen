package mml

import (
	"fmt"
	"io"
	"strconv"
)

// AST is the root element of the abstract syntax tree generated by the
// parser. It encapsulates all of the commands that make up a piece of music.
type AST struct {
	Sequence []Command
}

// Command defines the commands that can be executed within a sheet of music.
// Commands can perform actions on the music state, from emitting a note to
// setting the tempo and so on.
type Command interface {
	Execute(e Executor) error
}

// Parser represents a parser.
type Parser struct {
	s *Scanner
	// Saved token
	tok Token
}

// NewParser returns a new instance of Parser.
func NewParser(r io.Reader) *Parser {
	return &Parser{
		s: NewScanner(r),
	}
}

func (p *Parser) scan() error {
	p.tok = p.s.Scan()
	if p.tok.Type() == TIllegal {
		return fmt.Errorf("invalid token '%s' at line %d col %d", p.tok.Ident(), p.tok.LineNum(), p.tok.ColNum())
	}
	return nil
}

// Parse returns an abstract syntax tree by parsing the input program with a
// recursive descent parser (though the language is simple enough that there
// is not currently any recursion involved).
func (p *Parser) Parse() (*AST, error) {
	err := p.scan()
	if err != nil {
		return nil, err
	}
	return p.parseSequence()
}

// parseToken returns true if the next token is the expected type and advances
// the next token if true
func (p *Parser) parseToken(typ TokenType) (bool, string, error) {
	if p.tok.Type() == typ {
		return true, p.tok.Ident(), p.scan()
	}
	return false, "", nil
}

func (p *Parser) parseNumeric() (bool, int, error) {
	found, ident, err := p.parseToken(TNumeric)
	if found {
		n, parseErr := strconv.ParseInt(ident, 10, 64)
		if parseErr != nil {
			return true, -1, parseErr
		}
		return found, int(n), err
	}
	return found, -1, err
}

func (p *Parser) parseNoteCommand(cmdTok Token) (Command, error) {
	var (
		modifier string
		numeric  = -1
		dot      bool
	)
	if found, ident, err := p.parseToken(TModifier); found {
		if err != nil {
			return nil, err
		}
		modifier = ident
	}
	if found, n, err := p.parseNumeric(); found {
		if err != nil {
			return nil, err
		}
		numeric = n
	}
	if found, _, err := p.parseToken(TDot); found {
		if err != nil {
			return nil, err
		}
		dot = true
	}
	return &NoteCommand{Note: cmdTok.Ident(), Modifier: modifier, Length: numeric, Dot: dot}, nil
}

func (p *Parser) parseRestCommand(cmdTok Token) (Command, error) {
	var (
		numeric = -1
		dot     bool
	)
	if found, n, err := p.parseNumeric(); found {
		if err != nil {
			return nil, err
		}
		numeric = n
	}
	if found, _, err := p.parseToken(TDot); found {
		if err != nil {
			return nil, err
		}
		dot = true
	}
	return &RestCommand{Length: numeric, Dot: dot}, nil
}

func (p *Parser) parseTempoCommand(cmdTok Token) (Command, error) {
	if found, tempo, err := p.parseNumeric(); found {
		if err != nil {
			return nil, err
		}
		return &TempoCommand{Tempo: tempo}, nil
	}
	return nil, fmt.Errorf("Tempo command at line %d col %d: expected numeric argument", cmdTok.LineNum(), cmdTok.ColNum())
}

func (p *Parser) parseLengthCommand(cmdTok Token) (Command, error) {
	var (
		length = -1
		dot    bool
	)
	if found, n, err := p.parseNumeric(); found {
		if err != nil {
			return nil, err
		}
		length = n
	}
	if found, _, err := p.parseToken(TDot); found {
		if err != nil {
			return nil, err
		}
		dot = true
	}
	if length == -1 {
		return nil, fmt.Errorf("Length command at line %d col %d: expected numeric argument", cmdTok.LineNum(), cmdTok.ColNum())
	}
	return &LengthCommand{Length: length, Dot: dot}, nil
}
func (p *Parser) parseOctaveCommand(cmdTok Token) (Command, error) {
	if found, octave, err := p.parseNumeric(); found {
		if err != nil {
			return nil, err
		}
		return &OctaveCommand{Octave: octave}, nil
	}
	return nil, fmt.Errorf("Octave command at line %d col %d: expected numeric argument", cmdTok.LineNum(), cmdTok.ColNum())
}

func (p *Parser) parseOctaveUpCommand(cmdTok Token) (Command, error) {
	return &OctaveUpCommand{}, nil
}

func (p *Parser) parseOctaveDownCommand(cmdTok Token) (Command, error) {
	return &OctaveDownCommand{}, nil
}

func (p *Parser) parseCommand() (Command, error) {
	cmdTok := p.tok
	err := p.scan()
	if err != nil {
		return nil, err
	}
	switch cmdTok.Type() {
	case TNote:
		return p.parseNoteCommand(cmdTok)
	case TRest:
		return p.parseRestCommand(cmdTok)
	case TTempo:
		return p.parseTempoCommand(cmdTok)
	case TLength:
		return p.parseLengthCommand(cmdTok)
	case TOctave:
		return p.parseOctaveCommand(cmdTok)
	case TOctaveUp:
		return p.parseOctaveUpCommand(cmdTok)
	case TOctaveDown:
		return p.parseOctaveDownCommand(cmdTok)
	case TEOF:
		return nil, nil
	default:
		return nil, fmt.Errorf("expected command, got '%s' at line %d col %d", cmdTok.Ident(), cmdTok.LineNum(), cmdTok.ColNum())
	}
}
func (p *Parser) parseSequence() (*AST, error) {
	ast := &AST{}
	for {
		cmd, err := p.parseCommand()
		if err != nil {
			return ast, err
		}
		if cmd == nil {
			break
		}
		ast.Sequence = append(ast.Sequence, cmd)
	}
	return ast, nil
}
