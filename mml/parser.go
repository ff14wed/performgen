package mml

import (
	"fmt"
	"io"
	"strconv"
)

// AST is the root element of the abstract syntax tree generated by the
// parser. It encapsulates all of the commands that make up a piece of music.
type AST struct {
	Sequence []Command
}

// Command defines the commands that can be executed within a sheet of music.
// Commands can perform actions on the music state, from emitting a note to
// setting the tempo and so on.
type Command interface {
	Execute(e Executor) error
}

// Parser represents a parser.
type Parser struct {
	s *Scanner
	// Saved token
	tok Token
}

// NewParser returns a new instance of Parser.
func NewParser(r io.Reader) *Parser {
	return &Parser{
		s: NewScanner(r),
	}
}

func (p *Parser) scan() error {
	p.tok = p.s.Scan()
	if p.tok.Type() == TIllegal {
		return fmt.Errorf("invalid token '%s' at line %d col %d", p.tok.Ident(), p.tok.LineNum(), p.tok.ColNum())
	}
	return nil
}

// Parse returns an abstract syntax tree by parsing the input program with a
// recursive descent parser (though the language is simple enough that there
// is not currently any recursion involved).
func (p *Parser) Parse() (*AST, error) {
	err := p.scan()
	if err != nil {
		return nil, err
	}
	return p.parseSequence()
}

func (p *Parser) parseNumeric() (int, error) {
	n, err := strconv.ParseInt(p.tok.Ident(), 10, 64)
	if err != nil {
		return -1, err
	}
	err = p.scan()
	return int(n), err
}

func (p *Parser) parseNoteCommand(cmdTok Token) (Command, error) {
	var (
		modifier string
		numeric  = -1
		err      error
	)
	switch p.tok.Type() {
	case TModifier:
		modifier = p.tok.Ident()
		err = p.scan()
		if err != nil {
			return nil, err
		}
		if p.tok.Type() != TNumeric {
			break
		}
		fallthrough
	case TNumeric:
		numeric, err = p.parseNumeric()
		if err != nil {
			return nil, err
		}
	}
	return &NoteCommand{Note: cmdTok.Ident(), Modifier: modifier, Length: numeric}, nil
}

func (p *Parser) parseRestCommand(cmdTok Token) (Command, error) {
	var (
		numeric = -1
		err     error
	)
	if p.tok.Type() == TNumeric {
		numeric, err = p.parseNumeric()
		if err != nil {
			return nil, err
		}
	}
	return &RestCommand{Length: numeric}, nil
}

func (p *Parser) parseTempoCommand(cmdTok Token) (Command, error) {
	if p.tok.Type() == TNumeric {
		tempo, err := p.parseNumeric()
		if err != nil {
			return nil, err
		}
		return &TempoCommand{Tempo: tempo}, nil
	}
	return nil, fmt.Errorf("Tempo command at line %d col %d: expected numeric argument", cmdTok.LineNum(), cmdTok.ColNum())
}

func (p *Parser) parseLengthCommand(cmdTok Token) (Command, error) {
	if p.tok.Type() == TNumeric {
		length, err := p.parseNumeric()
		if err != nil {
			return nil, err
		}
		return &LengthCommand{Length: length}, nil
	}
	return nil, fmt.Errorf("Length command at line %d col %d: expected numeric argument", cmdTok.LineNum(), cmdTok.ColNum())
}
func (p *Parser) parseOctaveCommand(cmdTok Token) (Command, error) {
	if p.tok.Type() == TNumeric {
		octave, err := p.parseNumeric()
		if err != nil {
			return nil, err
		}
		return &OctaveCommand{Octave: octave}, nil
	}
	return nil, fmt.Errorf("Octave command at line %d col %d: expected numeric argument", cmdTok.LineNum(), cmdTok.ColNum())
}

func (p *Parser) parseOctaveUpCommand(cmdTok Token) (Command, error) {
	return &OctaveUpCommand{}, nil
}

func (p *Parser) parseOctaveDownCommand(cmdTok Token) (Command, error) {
	return &OctaveDownCommand{}, nil
}

func (p *Parser) parseCommand() (Command, error) {
	cmdTok := p.tok
	err := p.scan()
	if err != nil {
		return nil, err
	}
	switch cmdTok.Type() {
	case TNote:
		return p.parseNoteCommand(cmdTok)
	case TRest:
		return p.parseRestCommand(cmdTok)
	case TTempo:
		return p.parseTempoCommand(cmdTok)
	case TLength:
		return p.parseLengthCommand(cmdTok)
	case TOctave:
		return p.parseOctaveCommand(cmdTok)
	case TOctaveUp:
		return p.parseOctaveUpCommand(cmdTok)
	case TOctaveDown:
		return p.parseOctaveDownCommand(cmdTok)
	case TEOF:
		return nil, nil
	default:
		return nil, fmt.Errorf("expected command, got '%s' at line %d col %d", cmdTok.Ident(), cmdTok.LineNum(), cmdTok.ColNum())
	}
}
func (p *Parser) parseSequence() (*AST, error) {
	ast := &AST{}
	for {
		cmd, err := p.parseCommand()
		if err != nil {
			return ast, err
		}
		if cmd == nil {
			break
		}
		ast.Sequence = append(ast.Sequence, cmd)
	}
	return ast, nil
}
