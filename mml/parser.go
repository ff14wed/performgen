package mml

import (
	"fmt"
	"io"
	"strconv"
)

// AST is the root element of the abstract syntax tree generated by the
// parser. It encapsulates all of the commands that make up a piece of music.
type AST struct {
	Sequence  []Command
	Positions []Position
}

// Command defines the commands that can be executed within a sheet of music.
// Commands can perform actions on the music state, from emitting a note to
// setting the tempo and so on.
type Command interface {
	Execute(e Executor) error
}

// Position identifies a location of the input string
type Position struct {
	Line   int
	Column int
}

func (p Position) String() string {
	return fmt.Sprintf("line %d, column %d", p.Line, p.Column)
}

// Parser represents a parser.
type Parser struct {
	s *Scanner
	// Saved token
	tok Token
}

// NewParser returns a new instance of Parser.
func NewParser(r io.Reader) *Parser {
	return &Parser{
		s: NewScanner(r),
	}
}

func (p *Parser) scan() error {
	p.tok = p.s.Scan()
	if p.tok.Type() == TIllegal {
		return fmt.Errorf("invalid token '%s' at %s", p.tok.Ident(), p.tok.Position())
	}
	return nil
}

// Parse returns an abstract syntax tree by parsing the input program with a
// recursive descent parser (though the language is simple enough that there
// is not currently any recursion involved).
func (p *Parser) Parse() (*AST, error) {
	err := p.scan()
	if err != nil {
		return nil, err
	}
	return p.parseSequence()
}

// parseToken returns true if the next token is the expected type and advances
// the next token if true
func (p *Parser) parseToken(typ TokenType) (bool, Token, error) {
	oldTok := p.tok
	if oldTok.Type() == typ {
		return true, oldTok, p.scan()
	}
	return false, Token{}, nil
}

func (p *Parser) parseNumeric() (bool, int, error) {
	found, tok, err := p.parseToken(TNumeric)
	if found {
		n, parseErr := strconv.ParseInt(tok.Ident(), 10, 64)
		if parseErr != nil {
			return true, -1, parseErr
		}
		return found, int(n), err
	}
	return found, -1, err
}

func (p *Parser) parseNoteCommand(cmdTok Token) (*NoteCommand, error) {
	var (
		modifier string
		numeric  = -1
		dot      bool
	)
	if found, tok, err := p.parseToken(TModifier); found {
		if err != nil {
			return nil, err
		}
		modifier = tok.Ident()
	}
	if found, n, err := p.parseNumeric(); found {
		if err != nil {
			return nil, err
		}
		numeric = n
	}
	if found, _, err := p.parseToken(TDot); found {
		if err != nil {
			return nil, err
		}
		dot = true
	}
	return &NoteCommand{Note: cmdTok.Ident(), Modifier: modifier, Length: numeric, Dot: dot}, nil
}

func (p *Parser) parseRestCommand(cmdTok Token) (*RestCommand, error) {
	var (
		numeric = -1
		dot     bool
	)
	if found, n, err := p.parseNumeric(); found {
		if err != nil {
			return nil, err
		}
		numeric = n
	}
	if found, _, err := p.parseToken(TDot); found {
		if err != nil {
			return nil, err
		}
		dot = true
	}
	return &RestCommand{Length: numeric, Dot: dot}, nil
}

func (p *Parser) parseTempoCommand(cmdTok Token) (*TempoCommand, error) {
	if found, tempo, err := p.parseNumeric(); found {
		if err != nil {
			return nil, err
		}
		return &TempoCommand{Tempo: tempo}, nil
	}
	return nil, fmt.Errorf("Tempo command at %s: expected numeric argument", cmdTok.Position())
}

func (p *Parser) parseLengthCommand(cmdTok Token) (*LengthCommand, error) {
	var (
		length = -1
		dot    bool
	)
	if found, n, err := p.parseNumeric(); found {
		if err != nil {
			return nil, err
		}
		length = n
	}
	if found, _, err := p.parseToken(TDot); found {
		if err != nil {
			return nil, err
		}
		dot = true
	}
	if length == -1 {
		return nil, fmt.Errorf("Length command at %s: expected numeric argument", cmdTok.Position())
	}
	return &LengthCommand{Length: length, Dot: dot}, nil
}
func (p *Parser) parseOctaveCommand(cmdTok Token) (*OctaveCommand, error) {
	if found, octave, err := p.parseNumeric(); found {
		if err != nil {
			return nil, err
		}
		return &OctaveCommand{Octave: octave}, nil
	}
	return nil, fmt.Errorf("Octave command at %s: expected numeric argument", cmdTok.Position())
}

func (p *Parser) parseOctaveUpCommand(cmdTok Token) (*OctaveUpCommand, error) {
	return &OctaveUpCommand{}, nil
}

func (p *Parser) parseOctaveDownCommand(cmdTok Token) (*OctaveDownCommand, error) {
	return &OctaveDownCommand{}, nil
}

func (p *Parser) parseVolumeCommand(cmdTok Token) (*NoOpCommand, error) {
	if found, _, err := p.parseNumeric(); found {
		if err != nil {
			return nil, err
		}
		return &NoOpCommand{}, nil
	}
	return nil, fmt.Errorf("Volume command at %s: expected numeric argument", cmdTok.Position())
}

func (p *Parser) parseExtendCommand(cmdTok Token) (*RestCommand, error) {
	if found, tok, err := p.parseToken(TNote); found {
		if err != nil {
			return nil, err
		}
		cmd, err := p.parseNoteCommand(tok)
		if err != nil {
			return nil, err
		}
		return &RestCommand{Length: cmd.Length}, nil
	} else if found, tok, err := p.parseToken(TRest); found {
		if err != nil {
			return nil, err
		}
		return p.parseRestCommand(tok)
	}
	return nil, fmt.Errorf("Extend command at %s: expected note or rest command", cmdTok.Position())
}

func (p *Parser) parseCommand() (Command, error) {
	cmdTok := p.tok
	err := p.scan()
	if err != nil {
		return nil, err
	}
	switch cmdTok.Type() {
	case TNote:
		return p.parseNoteCommand(cmdTok)
	case TRest:
		return p.parseRestCommand(cmdTok)
	case TTempo:
		return p.parseTempoCommand(cmdTok)
	case TLength:
		return p.parseLengthCommand(cmdTok)
	case TOctave:
		return p.parseOctaveCommand(cmdTok)
	case TOctaveUp:
		return p.parseOctaveUpCommand(cmdTok)
	case TOctaveDown:
		return p.parseOctaveDownCommand(cmdTok)
	case TVolume:
		return p.parseVolumeCommand(cmdTok)
	case TExtend:
		return p.parseExtendCommand(cmdTok)
	case TEOF:
		return nil, nil
	default:
		return nil, fmt.Errorf("expected command, got '%s' at %s", cmdTok.Ident(), cmdTok.Position())
	}
}
func (p *Parser) parseSequence() (*AST, error) {
	ast := &AST{}
	for {
		pos := p.tok.Position()
		cmd, err := p.parseCommand()
		if err != nil {
			return ast, err
		}
		if cmd == nil {
			break
		}
		ast.Sequence = append(ast.Sequence, cmd)
		ast.Positions = append(ast.Positions, pos)
	}
	return ast, nil
}
