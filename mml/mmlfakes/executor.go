// Code generated by counterfeiter. DO NOT EDIT.
package mmlfakes

import (
	"sync"

	"github.com/ff14wed/performgen/mml"
)

type Executor struct {
	EmitNoteStub        func(note string, modifier string, length int) error
	emitNoteMutex       sync.RWMutex
	emitNoteArgsForCall []struct {
		note     string
		modifier string
		length   int
	}
	emitNoteReturns struct {
		result1 error
	}
	emitNoteReturnsOnCall map[int]struct {
		result1 error
	}
	EmitRestStub        func(length int) error
	emitRestMutex       sync.RWMutex
	emitRestArgsForCall []struct {
		length int
	}
	emitRestReturns struct {
		result1 error
	}
	emitRestReturnsOnCall map[int]struct {
		result1 error
	}
	SetTempoStub        func(t int) error
	setTempoMutex       sync.RWMutex
	setTempoArgsForCall []struct {
		t int
	}
	setTempoReturns struct {
		result1 error
	}
	setTempoReturnsOnCall map[int]struct {
		result1 error
	}
	SetDefaultLengthStub        func(l int) error
	setDefaultLengthMutex       sync.RWMutex
	setDefaultLengthArgsForCall []struct {
		l int
	}
	setDefaultLengthReturns struct {
		result1 error
	}
	setDefaultLengthReturnsOnCall map[int]struct {
		result1 error
	}
	SetOctaveStub        func(o int) error
	setOctaveMutex       sync.RWMutex
	setOctaveArgsForCall []struct {
		o int
	}
	setOctaveReturns struct {
		result1 error
	}
	setOctaveReturnsOnCall map[int]struct {
		result1 error
	}
	CurrentOctaveStub        func() int
	currentOctaveMutex       sync.RWMutex
	currentOctaveArgsForCall []struct{}
	currentOctaveReturns     struct {
		result1 int
	}
	currentOctaveReturnsOnCall map[int]struct {
		result1 int
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *Executor) EmitNote(note string, modifier string, length int) error {
	fake.emitNoteMutex.Lock()
	ret, specificReturn := fake.emitNoteReturnsOnCall[len(fake.emitNoteArgsForCall)]
	fake.emitNoteArgsForCall = append(fake.emitNoteArgsForCall, struct {
		note     string
		modifier string
		length   int
	}{note, modifier, length})
	fake.recordInvocation("EmitNote", []interface{}{note, modifier, length})
	fake.emitNoteMutex.Unlock()
	if fake.EmitNoteStub != nil {
		return fake.EmitNoteStub(note, modifier, length)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.emitNoteReturns.result1
}

func (fake *Executor) EmitNoteCallCount() int {
	fake.emitNoteMutex.RLock()
	defer fake.emitNoteMutex.RUnlock()
	return len(fake.emitNoteArgsForCall)
}

func (fake *Executor) EmitNoteArgsForCall(i int) (string, string, int) {
	fake.emitNoteMutex.RLock()
	defer fake.emitNoteMutex.RUnlock()
	return fake.emitNoteArgsForCall[i].note, fake.emitNoteArgsForCall[i].modifier, fake.emitNoteArgsForCall[i].length
}

func (fake *Executor) EmitNoteReturns(result1 error) {
	fake.EmitNoteStub = nil
	fake.emitNoteReturns = struct {
		result1 error
	}{result1}
}

func (fake *Executor) EmitNoteReturnsOnCall(i int, result1 error) {
	fake.EmitNoteStub = nil
	if fake.emitNoteReturnsOnCall == nil {
		fake.emitNoteReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.emitNoteReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Executor) EmitRest(length int) error {
	fake.emitRestMutex.Lock()
	ret, specificReturn := fake.emitRestReturnsOnCall[len(fake.emitRestArgsForCall)]
	fake.emitRestArgsForCall = append(fake.emitRestArgsForCall, struct {
		length int
	}{length})
	fake.recordInvocation("EmitRest", []interface{}{length})
	fake.emitRestMutex.Unlock()
	if fake.EmitRestStub != nil {
		return fake.EmitRestStub(length)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.emitRestReturns.result1
}

func (fake *Executor) EmitRestCallCount() int {
	fake.emitRestMutex.RLock()
	defer fake.emitRestMutex.RUnlock()
	return len(fake.emitRestArgsForCall)
}

func (fake *Executor) EmitRestArgsForCall(i int) int {
	fake.emitRestMutex.RLock()
	defer fake.emitRestMutex.RUnlock()
	return fake.emitRestArgsForCall[i].length
}

func (fake *Executor) EmitRestReturns(result1 error) {
	fake.EmitRestStub = nil
	fake.emitRestReturns = struct {
		result1 error
	}{result1}
}

func (fake *Executor) EmitRestReturnsOnCall(i int, result1 error) {
	fake.EmitRestStub = nil
	if fake.emitRestReturnsOnCall == nil {
		fake.emitRestReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.emitRestReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Executor) SetTempo(t int) error {
	fake.setTempoMutex.Lock()
	ret, specificReturn := fake.setTempoReturnsOnCall[len(fake.setTempoArgsForCall)]
	fake.setTempoArgsForCall = append(fake.setTempoArgsForCall, struct {
		t int
	}{t})
	fake.recordInvocation("SetTempo", []interface{}{t})
	fake.setTempoMutex.Unlock()
	if fake.SetTempoStub != nil {
		return fake.SetTempoStub(t)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.setTempoReturns.result1
}

func (fake *Executor) SetTempoCallCount() int {
	fake.setTempoMutex.RLock()
	defer fake.setTempoMutex.RUnlock()
	return len(fake.setTempoArgsForCall)
}

func (fake *Executor) SetTempoArgsForCall(i int) int {
	fake.setTempoMutex.RLock()
	defer fake.setTempoMutex.RUnlock()
	return fake.setTempoArgsForCall[i].t
}

func (fake *Executor) SetTempoReturns(result1 error) {
	fake.SetTempoStub = nil
	fake.setTempoReturns = struct {
		result1 error
	}{result1}
}

func (fake *Executor) SetTempoReturnsOnCall(i int, result1 error) {
	fake.SetTempoStub = nil
	if fake.setTempoReturnsOnCall == nil {
		fake.setTempoReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setTempoReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Executor) SetDefaultLength(l int) error {
	fake.setDefaultLengthMutex.Lock()
	ret, specificReturn := fake.setDefaultLengthReturnsOnCall[len(fake.setDefaultLengthArgsForCall)]
	fake.setDefaultLengthArgsForCall = append(fake.setDefaultLengthArgsForCall, struct {
		l int
	}{l})
	fake.recordInvocation("SetDefaultLength", []interface{}{l})
	fake.setDefaultLengthMutex.Unlock()
	if fake.SetDefaultLengthStub != nil {
		return fake.SetDefaultLengthStub(l)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.setDefaultLengthReturns.result1
}

func (fake *Executor) SetDefaultLengthCallCount() int {
	fake.setDefaultLengthMutex.RLock()
	defer fake.setDefaultLengthMutex.RUnlock()
	return len(fake.setDefaultLengthArgsForCall)
}

func (fake *Executor) SetDefaultLengthArgsForCall(i int) int {
	fake.setDefaultLengthMutex.RLock()
	defer fake.setDefaultLengthMutex.RUnlock()
	return fake.setDefaultLengthArgsForCall[i].l
}

func (fake *Executor) SetDefaultLengthReturns(result1 error) {
	fake.SetDefaultLengthStub = nil
	fake.setDefaultLengthReturns = struct {
		result1 error
	}{result1}
}

func (fake *Executor) SetDefaultLengthReturnsOnCall(i int, result1 error) {
	fake.SetDefaultLengthStub = nil
	if fake.setDefaultLengthReturnsOnCall == nil {
		fake.setDefaultLengthReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setDefaultLengthReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Executor) SetOctave(o int) error {
	fake.setOctaveMutex.Lock()
	ret, specificReturn := fake.setOctaveReturnsOnCall[len(fake.setOctaveArgsForCall)]
	fake.setOctaveArgsForCall = append(fake.setOctaveArgsForCall, struct {
		o int
	}{o})
	fake.recordInvocation("SetOctave", []interface{}{o})
	fake.setOctaveMutex.Unlock()
	if fake.SetOctaveStub != nil {
		return fake.SetOctaveStub(o)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.setOctaveReturns.result1
}

func (fake *Executor) SetOctaveCallCount() int {
	fake.setOctaveMutex.RLock()
	defer fake.setOctaveMutex.RUnlock()
	return len(fake.setOctaveArgsForCall)
}

func (fake *Executor) SetOctaveArgsForCall(i int) int {
	fake.setOctaveMutex.RLock()
	defer fake.setOctaveMutex.RUnlock()
	return fake.setOctaveArgsForCall[i].o
}

func (fake *Executor) SetOctaveReturns(result1 error) {
	fake.SetOctaveStub = nil
	fake.setOctaveReturns = struct {
		result1 error
	}{result1}
}

func (fake *Executor) SetOctaveReturnsOnCall(i int, result1 error) {
	fake.SetOctaveStub = nil
	if fake.setOctaveReturnsOnCall == nil {
		fake.setOctaveReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setOctaveReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Executor) CurrentOctave() int {
	fake.currentOctaveMutex.Lock()
	ret, specificReturn := fake.currentOctaveReturnsOnCall[len(fake.currentOctaveArgsForCall)]
	fake.currentOctaveArgsForCall = append(fake.currentOctaveArgsForCall, struct{}{})
	fake.recordInvocation("CurrentOctave", []interface{}{})
	fake.currentOctaveMutex.Unlock()
	if fake.CurrentOctaveStub != nil {
		return fake.CurrentOctaveStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.currentOctaveReturns.result1
}

func (fake *Executor) CurrentOctaveCallCount() int {
	fake.currentOctaveMutex.RLock()
	defer fake.currentOctaveMutex.RUnlock()
	return len(fake.currentOctaveArgsForCall)
}

func (fake *Executor) CurrentOctaveReturns(result1 int) {
	fake.CurrentOctaveStub = nil
	fake.currentOctaveReturns = struct {
		result1 int
	}{result1}
}

func (fake *Executor) CurrentOctaveReturnsOnCall(i int, result1 int) {
	fake.CurrentOctaveStub = nil
	if fake.currentOctaveReturnsOnCall == nil {
		fake.currentOctaveReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.currentOctaveReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *Executor) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.emitNoteMutex.RLock()
	defer fake.emitNoteMutex.RUnlock()
	fake.emitRestMutex.RLock()
	defer fake.emitRestMutex.RUnlock()
	fake.setTempoMutex.RLock()
	defer fake.setTempoMutex.RUnlock()
	fake.setDefaultLengthMutex.RLock()
	defer fake.setDefaultLengthMutex.RUnlock()
	fake.setOctaveMutex.RLock()
	defer fake.setOctaveMutex.RUnlock()
	fake.currentOctaveMutex.RLock()
	defer fake.currentOctaveMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *Executor) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ mml.Executor = new(Executor)
